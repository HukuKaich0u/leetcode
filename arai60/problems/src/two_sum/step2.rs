// Step2
// 目的: 自然な書き方を考えて整理する

// 方法
// Step1のコードを読みやすくしてみる
// 他の人のコードを2つは読んでみること
// 正解したら終わり

// 以下をメモに残すこと
// 講師陣はどのようなコメントを残すだろうか？
// 他の人のコードを読んで考えたこと
// 改善する時に考えたこと

/*
  講師陣はどのようなコメントを残すだろうか？
  - if内の処理が冗長、無駄。
  - iとjのインデックスが異なることを表現する処理が稚拙というか。
  - 最初にVec宣言したなら、そのあと何かVecを使った処理が続くのかと思いきや、
pushして返すだけなら、はなからreturnでvec!を返したらいい。
  - forでiとjって適当に命名してるけど、意味がわからないので、なんのためのループのインデックスなのか
意図が伝わるように命名した方がいい。indexとnumberとか。

  他の人のコードを読んで考えたこと
  - (t9a-devさんのコード)
  -- forで、iter().enumerate()を使って、配列のインデックスと
要素を取り出して、何をしたいのかがこの時点で推測できる。自分のコードはそのあとの処理を見るまで、
何をしてるんだこいつは、ってなりそうなコードで表現が稚拙な感じ。
  - (Yoshiki Iwasaさんのコード)
  -- HashMapを使う学びになったし、get()で要素にアクセスして、Option<T>をmatchで
処理してるのが実際の開発に通用するコードで本当に学びになる。計算量もO(n)ですむので、
自分のコードとは完成度が違う。

  - 配列内の2要素の和がtargetになるって話を、どうしてt9a-devさんもYoshiki Iwasaさんも
for以下の処理で表現できたのか、発想というかロジックというか....


  他の想定ユースケース
  -

  改善する時に考えたこと
  - 最初にVec宣言してあとからpushするくらいなら、戻り値でそのままVec返せばいいじゃん。
*/


// 自分流のコード
impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        for i in 0..nums.len() {
            // iとjが異なるという条件を表現している
            for j in (j+1)..nums.len() {

                if nums[i] + nums[j] == target {
                    return vec![i as i32, j as i32];
                }
            }
        }

        vec![]
    }
}
